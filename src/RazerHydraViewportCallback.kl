/*
 *  Copyright 2010-2014 Fabric Software Inc. All rights reserved.
 */

require InlineDrawing:">1.0.0";
require Singletons;

object RazerHydraViewportCallback : ViewportCallback {
  RazerHydraController controller;
  Float32 walkSpeed;
  Float32 turnSpeed;
  Boolean requiresUpdate;
};

function RazerHydraViewportCallback() {
  this.init(RazerHydraController());
  this.requiresUpdate = true;
}

function RazerHydraViewportCallback(RazerHydraController controller) {
  this.init(controller);
  this.requiresUpdate = false;
}

function RazerHydraViewportCallback.init!(RazerHydraController controller) {
  this.controller = controller;
  this.walkSpeed = 1.0;
  this.turnSpeed = 1.0;
}

function RazerHydraViewportCallback.registerForViewport!(String viewportName) {
  InlineDrawing drawing = Singleton_get('InlineDrawing');
  Viewport viewport = drawing.getViewport(viewportName);
  if(viewport) {
    viewport.registerCallback(ViewportDrawPhase_PreDraw, this);
  }
}

function RazerHydraViewportCallback.registerForViewport!() {
  this.registerForViewport('default');
}

function Boolean RazerHydraViewportCallback.invoke!(ViewportDrawPhase phase, io Viewport viewport, io DrawContext context) {
  switch(phase) {

    case ViewportDrawPhase_PreDraw: {

      if(this.requiresUpdate)
        this.controller.update();

      Float32 x = this.controller.controls[0].joystick_x;
      Float32 y = 0.0;
      Float32 z = this.controller.controls[0].joystick_y;

      if(this.controller.controls[0].buttons & SIXENSE_BUTTON_3)
        y = 1.0;
      else if(this.controller.controls[0].buttons & SIXENSE_BUTTON_1)
        y = -1.0;

      InlineCamera camera = viewport.getCamera();

      camera.goalLinearVelocity.x = x * this.walkSpeed * 0.25;
      camera.goalLinearVelocity.y = y * this.walkSpeed * 0.25;
      camera.goalLinearVelocity.z = -z * this.walkSpeed * 0.25;

      x = this.controller.controls[1].joystick_x;
      y = this.controller.controls[1].joystick_y;

      camera.goalAngularVelocity.x = -x * this.turnSpeed * 0.02;
      camera.goalAngularVelocity.y = y * this.turnSpeed * 0.02;

      camera.update();
    }
  }
  return false;
}
